# Μονάδα Τεχνητής Νοημοσύνης Σκακιστικής Μηχανής (chess_engine.py)

## Επισκόπηση
Αυτή η μονάδα υλοποιεί μια μηχανή τεχνητής νοημοσύνης για σκάκι χρησιμοποιώντας τον αλγόριθμο Minimax με κλάδεμα alpha-beta για αναζήτηση κινήσεων. Η μηχανή έχει διαμορφώσιμα επίπεδα δυσκολίας που καθορίζουν το βάθος αναζήτησης του αλγόριθμου. Λειτουργεί τόσο ως κύρια τεχνητή νοημοσύνη για παιχνίδια παίκτη εναντίον υπολογιστή όσο και ως εφεδρική για την CloneEngine όταν δεν μπορούν να βρεθούν κινήσεις συγκεκριμένες για τον παίκτη.

## Ανάλυση Γραμμή προς Γραμμή

### Εισαγωγές
```python
import random
import time
from copy import deepcopy
from ..config import BOARD_SIZE
```
- Εισάγει τις απαραίτητες βιβλιοθήκες:
  - `random`: Χρησιμοποιείται για την επιλογή τυχαίων κινήσεων σε εύκολο επίπεδο δυσκολίας
  - `time`: Χρησιμοποιείται για την προσθήκη καθυστερήσεων για προσομοίωση σκέψης
  - `deepcopy`: Χρησιμοποιείται για τη δημιουργία βαθιών αντιγράφων της κατάστασης της σκακιέρας για αξιολόγηση κινήσεων
  - `BOARD_SIZE`: Σταθερά διαμόρφωσης για το μέγεθος της σκακιέρας

### Ορισμός Κλάσης
```python
class ChessEngine:
    """
    Μια απλή υλοποίηση μηχανής σκακιού που χρησιμοποιεί τον αλγόριθμο Minimax 
    με alpha-beta κλάδεμα για αναζήτηση κινήσεων.
    """
```
- Ορίζει την κλάση ChessEngine με μια ελληνική περιγραφή που την περιγράφει ως μια απλή μηχανή σκακιού που χρησιμοποιεί αλγόριθμο Minimax με κλάδεμα alpha-beta για αναζήτηση κινήσεων

### Μέθοδος Αρχικοποίησης
```python
def __init__(self, difficulty=2):
    """
    Αρχικοποίηση της μηχανής σκακιού
    difficulty: επίπεδο δυσκολίας (1-3)
        - 1: Εύκολο (βάθος αναζήτησης 1)
        - 2: Μεσαίο (βάθος αναζήτησης 2)
        - 3: Δύσκολο (βάθος αναζήτησης 3)
    """
    self.difficulty = difficulty
    self.search_depth = difficulty
```
- Κατασκευαστής που δέχεται μια παράμετρο δυσκολίας (προεπιλογή: 2)
- Η ελληνική περιγραφή εξηγεί τα επίπεδα δυσκολίας:
  - 1: Εύκολο (βάθος αναζήτησης 1)
  - 2: Μεσαίο (βάθος αναζήτησης 2)
  - 3: Δύσκολο (βάθος αναζήτησης 3)
- Ορίζει το βάθος αναζήτησης ίσο με το επίπεδο δυσκολίας

```python
# Αξίες κομματιών για την αξιολόγηση θέσης
self.piece_values = {
    'p': 10,    # Στρατιώτης
    'n': 30,    # Ίππος
    'b': 30,    # Αξιωματικός
    'r': 50,    # Πύργος
    'q': 90,    # Βασίλισσα
    'k': 900    # Βασιλιάς
}
```
- Ορίζει τις αξίες των κομματιών για την αξιολόγηση της σκακιέρας:
  - Πιόνι: 10 πόντοι
  - Ίππος: 30 πόντοι
  - Αξιωματικός: 30 πόντοι
  - Πύργος: 50 πόντοι
  - Βασίλισσα: 90 πόντοι
  - Βασιλιάς: 900 πόντοι (υψηλή αξία αντανακλά τη σημασία του)

### Μέθοδος Επιλογής Καλύτερης Κίνησης
```python
def get_best_move(self, board, is_maximizing=False):
    """
    Αναζήτηση καλύτερης κίνησης για τον μαύρο παίκτη (AI)
    """
    # Κάνουμε μια μικρή καθυστέρηση για να φαίνεται πιο φυσικό
    time.sleep(0.5)
```
- Η κύρια μέθοδος για την εύρεση της καλύτερης κίνησης για τον παίκτη τεχνητής νοημοσύνης (μαύρα)
- Προσθέτει μισό δευτερόλεπτο καθυστέρηση ώστε η απόκριση της τεχνητής νοημοσύνης να φαίνεται πιο φυσική/ανθρώπινη

```python
# Σε πολύ χαμηλό επίπεδο δυσκολίας, επιλέγουμε τυχαία κίνηση από τις δυνατές
if self.difficulty == 0:
    return self.get_random_move(board)
```
- Για επίπεδο δυσκολίας 0 (πολύ εύκολο), επιστρέφει μια τυχαία έγκυρη κίνηση
- Αυτό παρέχει έναν πολύ φιλικό για αρχάριους αντίπαλο

```python
# Συλλογή όλων των δυνατών κινήσεων - χρησιμοποιώντας τον κανονικό έλεγχο του board
all_moves = []

# Διατρέχουμε όλα τα πιόνια του μαύρου παίκτη και παίρνουμε έγκυρες κινήσεις
for row in range(BOARD_SIZE):
    for col in range(BOARD_SIZE):
        piece = board.get_piece_at(row, col)
        if piece and piece[0] == 'b':
            # Παίρνουμε έγκυρες κινήσεις (που δεν οδηγούν σε σαχ) από τη μέθοδο του board
            valid_moves = board.get_valid_moves(row, col)
            for move in valid_moves:
                all_moves.append(((row, col), move))
```
- Συλλέγει όλες τις έγκυρες κινήσεις για τον μαύρο παίκτη
- Διατρέχει κάθε τετράγωνο στη σκακιέρα
- Για κάθε μαύρο κομμάτι, λαμβάνει όλες τις έγκυρες κινήσεις από το σύστημα επικύρωσης της σκακιέρας
- Προσθέτει κάθε κίνηση ως μια πλειάδα θέσεων: (from_position, to_position)

```python
# Αν δεν υπάρχουν κινήσεις, επιστρέφουμε None
if not all_moves:
    return None
```
- Επιστρέφει None αν δεν υπάρχουν διαθέσιμες έγκυρες κινήσεις

```python
best_move = None
best_score = float('-inf')

# Αναζήτηση καλύτερης κίνησης με minimax
for from_pos, to_pos in all_moves:
    # Δημιουργία αντιγράφου της σκακιέρας για δοκιμή κίνησης
    temp_board = deepcopy(board)
    
    # Εκτέλεση κίνησης στο αντίγραφο
    self.make_temp_move(temp_board, from_pos, to_pos)
    
    # Αξιολόγηση κίνησης με minimax
    score = self.minimax(temp_board, self.search_depth - 1, float('-inf'), float('inf'), False)
    
    if score > best_score:
        best_score = score
        best_move = (from_pos, to_pos)

return best_move
```
- Χρησιμοποιεί τον αλγόριθμο Minimax για την αξιολόγηση όλων των πιθανών κινήσεων
- Για κάθε κίνηση:
  - Δημιουργεί ένα βαθύ αντίγραφο της σκακιέρας για να αποφύγει την τροποποίηση της αρχικής
  - Εκτελεί την κίνηση στο αντίγραφο
  - Αξιολογεί την προκύπτουσα θέση χρησιμοποιώντας Minimax με κλάδεμα alpha-beta
  - Ενημερώνει την καλύτερη κίνηση αν βρεθεί καλύτερη βαθμολογία
- Επιστρέφει την καλύτερη κίνηση που βρέθηκε

### Μέθοδος Επιλογής Τυχαίας Κίνησης
```python
def get_random_move(self, board):
    """Επιλογή τυχαίας κίνησης από τις διαθέσιμες"""
    all_moves = []
    
    # Διατρέχουμε όλα τα πιόνια του μαύρου παίκτη και παίρνουμε έγκυρες κινήσεις
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            piece = board.get_piece_at(row, col)
            if piece and piece[0] == 'b':
                # Παίρνουμε έγκυρες κινήσεις από τη μέθοδο του board
                valid_moves = board.get_valid_moves(row, col)
                for move in valid_moves:
                    all_moves.append(((row, col), move))
                    
    return random.choice(all_moves) if all_moves else None
```
- Βοηθητική μέθοδος για το ευκολότερο επίπεδο δυσκολίας
- Συλλέγει όλες τις έγκυρες κινήσεις για τα μαύρα κομμάτια
- Επιστρέφει μια τυχαία κίνηση από τη λίστα, ή None αν δεν υπάρχουν διαθέσιμες κινήσεις

### Μέθοδος Συλλογής Κινήσεων
```python
def get_all_moves(self, board, color):
    """Συλλογή όλων των δυνατών κινήσεων για τον παίκτη με το συγκεκριμένο χρώμα"""
    moves = []
    
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            piece = board.get_piece_at(row, col)
            if piece και piece[0] == color:
                # Παίρνουμε όλες τις έγκυρες κινήσεις για το πιόνι
                valid_moves = board.get_valid_moves(row, col)
                # Προσθέτουμε τις κινήσεις στη λίστα
                for move in valid_moves:
                    moves.append(((row, col), move))
    
    return moves
```
- Γενική βοηθητική μέθοδος για τη συλλογή όλων των έγκυρων κινήσεων για έναν παίκτη συγκεκριμένου χρώματος
- Χρησιμοποιείται από τον αλγόριθμο Minimax για την αξιολόγηση πιθανών κινήσεων και για τους δύο παίκτες

### Μέθοδος Εκτέλεσης Προσωρινής Κίνησης
```python
def make_temp_move(self, board, from_pos, to_pos):
    """Εκτελεί προσωρινή κίνηση στη σκακιέρα για αξιολόγηση"""
    from_row, from_col = from_pos
    to_row, to_col = to_pos
    
    # Αποθήκευση πιονιού που κινείται
    moving_piece = board.board[from_row][from_col]
    
    # Αποθήκευση του πιονιού στη θέση προορισμού (αν υπάρχει)
    captured_piece = board.board[to_row][to_col]
```
- Εκτελεί μια κίνηση σε ένα προσωρινό αντίγραφο της σκακιέρας για σκοπούς αξιολόγησης
- Αρχικά εξάγει τις θέσεις και εντοπίζει το κινούμενο κομμάτι και τυχόν αιχμαλωτισμένο κομμάτι

```python
# Έλεγχος για αποφυγή λήψης βασιλιά (αυτό είναι παράνομη κίνηση)
if captured_piece and captured_piece[1] == 'k':
    # Προσθήκη κώδικα επιβεβαίωσης για αποφυγή λήψης βασιλιά
    board.in_check = True
    board.checkmate = True
    board.game_over = True
    
    # Καθορισμός του νικητή με βάση το χρώμα του βασιλιά που θα έπαιρνε
    if captured_piece[0] == 'w':
        board.turn = 'w'  # Για να δείξει ότι ο λευκός έχασε
    else:
        board.turn = 'b'  # Για να δείξει ότι ο μαύρος έχασε
    return
```
- Χειρίζεται την περίπτωση όπου θα αιχμαλωτιζόταν ένας βασιλιάς (το οποίο δεν θα πρέπει να συμβεί σε έγκυρο σκάκι)
- Ορίζει τις κατάλληλες μεταβλητές κατάστασης παιχνιδιού για ρουά-ματ και τέλος παιχνιδιού
- Ορίζει τη σειρά για να υποδείξει ποιος παίκτης έχασε

```python
# Ενημέρωση θέσης βασιλιά εάν κινείται
if moving_piece[1] == 'k':
    if moving_piece[0] == 'w':
        board.white_king_pos = (to_row, to_col)
    else:
        board.black_king_pos = (to_row, to_col)
```
- Ενημερώνει την παρακολούθηση της θέσης του βασιλιά αν κινείται ένας βασιλιάς

```python
# Εκτέλεση κίνησης
board.board[to_row][to_col] = moving_piece
board.board[from_row][from_col] = ''

# Αλλαγή γύρου
board.turn = 'w' if board.turn == 'b' else 'b'
```
- Εκτελεί στην πράξη την κίνηση στη σκακιέρα ενημερώνοντας τους πίνακες
- Ενημερώνει τη σειρά στον αντίθετο παίκτη

```python
# Απλοποιημένος έλεγχος για προαγωγή πιονιού
if moving_piece[1] == 'p':
    if (moving_piece[0] == 'w' and to_row == 0) or (moving_piece[0] == 'b' and to_row == 7):
        board.board[to_row][to_col] = moving_piece[0] + 'q'  # Προαγωγή σε βασίλισσα
```
- Απλοποιημένος έλεγχος προαγωγής πιονιού
- Προάγει αυτόματα τα πιόνια σε βασίλισσες όταν φτάνουν στο αντίθετο άκρο της σκακιέρας

### Υλοποίηση Αλγόριθμου Minimax
```python
def minimax(self, board, depth, alpha, beta, is_maximizing):
    """Αλγόριθμος Minimax με κλάδεμα alpha-beta για αναζήτηση καλύτερης κίνησης"""
    # Βασική περίπτωση: φτάσαμε στο μέγιστο βάθος ή τέλος παιχνιδιού
    if depth == 0 ή board.checkmate ή board.is_stalemate():
        return self.evaluate_board(board)
```
- Υλοποιεί τον αλγόριθμο Minimax με κλάδεμα alpha-beta για αναζήτηση της καλύτερης κίνησης
- Οι βασικές περιπτώσεις είναι όταν:
  - Φτάνουμε στο μέγιστο βάθος αναζήτησης
  - Το παιχνίδι έχει τελειώσει (ρουά-ματ ή πατ)
- Σε αυτές τις περιπτώσεις, αξιολογεί την τρέχουσα θέση της σκακιέρας

```python
if is_maximizing:  # Maximizing player (μαύρα)
    best_score = float('-inf')
    all_moves = self.get_all_moves(board, 'b')
    
    for from_pos, to_pos in all_moves:
        temp_board = deepcopy(board)
        self.make_temp_move(temp_board, from_pos, to_pos)
        score = self.minimax(temp_board, depth - 1, alpha, beta, False)
        best_score = max(best_score, score)
        alpha = max(alpha, best_score)
        if beta <= alpha:
            break
    return best_score
```
- Χειρίζεται τη σειρά του μεγιστοποιητή παίκτη (μαύρα)
- Ξεκινά με αρνητικό άπειρο ως την καλύτερη βαθμολογία
- Για κάθε πιθανή κίνηση:
  - Δημιουργεί ένα αντίγραφο της σκακιέρας και κάνει την κίνηση
  - Αξιολογεί αναδρομικά την προκύπτουσα θέση με μειωμένο βάθος
  - Ενημερώνει την καλύτερη βαθμολογία και την τιμή alpha
  - Εκτελεί κλάδεμα alpha-beta για να παραλείψει την αξιολόγηση περιττών κλάδων
- Επιστρέφει την καλύτερη βαθμολογία που βρέθηκε

```python
else:  # Minimizing player (λευκά)
    best_score = float('inf')
    all_moves = self.get_all_moves(board, 'w')
    
    for from_pos, to_pos in all_moves:
        temp_board = deepcopy(board)
        self.make_temp_move(temp_board, from_pos, to_pos)
        score = self.minimax(temp_board, depth - 1, alpha, beta, True)
        best_score = min(best_score, score)
        beta = min(beta, best_score)
        if beta <= alpha:
            break
    return best_score
```
- Χειρίζεται τη σειρά του ελαχιστοποιητή παίκτη (λευκά)
- Λειτουργεί παρόμοια με την περίπτωση του μεγιστοποιητή, αλλά:
  - Ξεκινά με θετικό άπειρο ως την καλύτερη βαθμολογία
  - Ενημερώνει την καλύτερη βαθμολογία με την ελάχιστη τιμή
  - Ενημερώνει το beta αντί για το alpha
- Επιστρέφει την καλύτερη (ελάχιστη) βαθμολογία που βρέθηκε

### Μέθοδος Αξιολόγησης Σκακιέρας
```python
def evaluate_board(self, board):
    """
    Αξιολόγηση θέσης σκακιέρας
    Θετικές τιμές ευνοούν τα μαύρα, αρνητικές τα λευκά
    """
    score = 0
    
    # Έλεγχος για τέλος παιχνιδιού
    if board.checkmate:
        return 10000 αν board.turn == 'w' αλλιώς -10000
```
- Αξιολογεί μια θέση σκακιέρας με ένα σύστημα βαθμολόγησης
- Θετικές βαθμολογίες ευνοούν τα μαύρα, αρνητικές βαθμολογίες ευνοούν τα λευκά
- Αν εντοπιστεί ρουά-ματ, επιστρέφει μια πολύ υψηλή βαθμολογία που υποδεικνύει νίκη/ήττα:
  - +10000 αν ο λευκός είναι σε ρουά-ματ (νικούν τα μαύρα)
  - -10000 αν ο μαύρος είναι σε ρουά-ματ (νικούν τα λευκά)

```python
if board.is_stalemate():
    return 0  # Ισοπαλία
```
- Επιστρέφει 0 για πατ (ισοπαλία)

```python
# Υπολογισμός υλικού και θέσης
for row in range(BOARD_SIZE):
    for col in range(BOARD_SIZE):
        piece = board.board[row][col]
        if piece:
            # Αξία υλικού
            value = self.piece_values[piece[1]]
            
            # Προσημασμένη τιμή ανάλογα με το χρώμα
            if piece[0] == 'b':
                score += value
                
                # Επιπλέον μπόνους για την προχωρημένη θέση στρατιωτών
                if piece[1] == 'p':
                    score += row * 0.5  # Μπόνους για προχωρημένους στρατιώτες
            else:
                score -= value
                
                # Επιπλέον μπόνους για την προχωρημένη θέση στρατιωτών
                if piece[1] == 'p':
                    score -= (7 - row) * 0.5
```
- Κύριος βρόχος αξιολόγησης που υπολογίζει την αξία του υλικού και τα θεσιακά μπόνους
- Για κάθε κομμάτι στη σκακιέρα:
  - Προσθέτει την αξία του στη βαθμολογία για τα μαύρα κομμάτια
  - Αφαιρεί την αξία του από τη βαθμολογία για τα λευκά κομμάτια
  - Δίνει επιπλέον πόντους για προχωρημένα πιόνια (πιόνια που έχουν κινηθεί μπροστά)
    - Για μαύρα πιόνια: υψηλότερη γραμμή σημαίνει πιο κοντά στην προαγωγή
    - Για λευκά πιόνια: χαμηλότερη γραμμή σημαίνει πιο κοντά στην προαγωγή

```python
# Μπόνους για τον έλεγχο του κέντρου (τετράγωνα 3,3 έως 4,4)
for row in range(3, 5):
    for col in range(3, 5):
        piece = board.board[row][col]
        if piece:
            if piece[0] == 'b':
                score += 0.5
            else:
                score -= 0.5
```
- Προσθέτει μπόνους για τον έλεγχο του κέντρου της σκακιέρας (τετράγωνα d4, d5, e4, e5)
- Ο έλεγχος του κέντρου είναι μια βασική στρατηγική σκακιού
- Προσθέτει 0.5 πόντους για κάθε κεντρικό τετράγωνο που ελέγχεται από τα μαύρα
- Αφαιρεί 0.5 πόντους για κάθε κεντρικό τετράγωνο που ελέγχεται από τα λευκά

```python
return score
```
- Επιστρέφει την τελική υπολογισμένη βαθμολογία της θέσης