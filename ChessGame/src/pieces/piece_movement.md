# Μονάδα Κίνησης Κομματιών (piece_movement.py)

## Επισκόπηση
Αυτή η μονάδα ορίζει τους κανόνες κίνησης για κάθε τύπο κομματιού σκακιού. Περιέχει συναρτήσεις που υπολογίζουν έγκυρες κινήσεις για κάθε κομμάτι με βάση την τρέχουσα κατάσταση της σκακιέρας και υλοποιεί λογική για την ανίχνευση καταστάσεων σαχ. Αυτές οι συναρτήσεις χρησιμοποιούνται από την κλάση ChessBoard για την επιβολή των κανόνων του σκακιού.

## Ανάλυση Κώδικα Γραμμή προς Γραμμή

### Εισαγωγές
```python
from ..config import BOARD_SIZE
```
- Εισάγει τη σταθερά BOARD_SIZE από τη μονάδα config, η οποία ορίζει τις διαστάσεις της σκακιέρας (8×8)

### Συνάρτηση Κίνησης Πιονιού
```python
def get_pawn_moves(board, row, col, color):
    moves = []
    direction = -1 if color == 'w' else 1
```
- Υπολογίζει τις έγκυρες κινήσεις για ένα πιόνι στην καθορισμένη θέση
- Ορίζει την κατεύθυνση της κίνησης: τα λευκά πιόνια κινούνται προς τα πάνω (-1 στο δείκτη γραμμής), τα μαύρα πιόνια κινούνται προς τα κάτω (+1)

```python
# Κίνηση μπροστά
if 0 <= row + direction < BOARD_SIZE and not board[row + direction][col]:
    moves.append((row + direction, col))
    
    # Κίνηση δύο τετραγώνων αν είναι η πρώτη κίνηση
    if (color == 'w' and row == 6) or (color == 'b' and row == 1):
        if not board[row + 2*direction][col]:
            moves.append((row + 2*direction, col))
```
- Ελέγχει αν το πιόνι μπορεί να κινηθεί ένα τετράγωνο προς τα εμπρός (αν το τετράγωνο είναι κενό)
- Αν είναι η πρώτη κίνηση του πιονιού (λευκό στη σειρά 6 ή μαύρο στη σειρά 1), ελέγχει αν μπορεί να κινηθεί δύο τετράγωνα προς τα εμπρός

```python
# Κίνηση διαγώνια για φάγωμα
for dcol in [-1, 1]:
    if 0 <= row + direction < BOARD_SIZE and 0 <= col + dcol < BOARD_SIZE:
        target = board[row + direction][col + dcol]
        if target and target[0] != color:
            moves.append((row + direction, col + dcol))

return moves
```
- Ελέγχει για διαγώνιες κινήσεις αιχμαλώτισης (εμπρός-αριστερά και εμπρός-δεξιά)
- Προσθέτει διαγώνιες κινήσεις μόνο αν υπάρχει κομμάτι του αντιπάλου για αιχμαλώτιση

### Συνάρτηση Κίνησης Πύργου
```python
def get_rook_moves(board, row, col, color):
    moves = []
    # Κίνηση κάθετα και οριζόντια
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        for dist in range(1, BOARD_SIZE):
            r, c = row + dr * dist, col + dc * dist
            if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
                break
```
- Υπολογίζει έγκυρες κινήσεις για έναν πύργο στην καθορισμένη θέση
- Οι πύργοι κινούνται οριζόντια και κάθετα προς τέσσερις κατευθύνσεις
- Για κάθε κατεύθυνση, ελέγχει κινήσεις σε αυξανόμενες αποστάσεις μέχρι να φτάσει στο άκρο της σκακιέρας

```python
target = board[r][c]
if not target:
    moves.append((r, c))
elif target[0] != color:
    moves.append((r, c))
    break
else:
    break
```
- Για κάθε θέση στη διαδρομή του πύργου:
  - Αν το τετράγωνο είναι κενό, είναι έγκυρη κίνηση
  - Αν το τετράγωνο έχει κομμάτι του αντιπάλου, είναι έγκυρη κίνηση αιχμαλώτισης (και ο πύργος δεν μπορεί να κινηθεί περαιτέρω προς αυτή την κατεύθυνση)
  - Αν το τετράγωνο έχει κομμάτι του ίδιου παίκτη, ο πύργος δεν μπορεί να κινηθεί εκεί (ή πέρα από αυτό)

### Συνάρτηση Κίνησης Ίππου
```python
def get_knight_moves(board, row, col, color):
    moves = []
    knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
    for dr, dc in knight_moves:
        r, c = row + dr, col + dc
        if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
            target = board[r][c]
            if not target or target[0] != color:
                moves.append((r, c))
```
- Υπολογίζει έγκυρες κινήσεις για έναν ίππο στην καθορισμένη θέση
- Οι ίπποι κινούνται σε σχήμα Γ: 2 τετράγωνα προς μία κατεύθυνση και 1 τετράγωνο κάθετα
- Ελέγχονται και οι οκτώ πιθανές κινήσεις σε σχήμα Γ
- Μια κίνηση είναι έγκυρη αν είναι εντός της σκακιέρας και το τετράγωνο-στόχος είτε είναι κενό είτε περιέχει κομμάτι του αντιπάλου

### Συνάρτηση Κίνησης Αξιωματικού
```python
def get_bishop_moves(board, row, col, color):
    moves = []
    # Diagonal moves
    for dr, dc in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
        for dist in range(1, BOARD_SIZE):
            r, c = row + dr * dist, col + dc * dist
            if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
                break
```
- Υπολογίζει έγκυρες κινήσεις για έναν αξιωματικό στην καθορισμένη θέση
- Οι αξιωματικοί κινούνται διαγώνια προς τέσσερις κατευθύνσεις
- Για κάθε κατεύθυνση, ελέγχει κινήσεις σε αυξανόμενες αποστάσεις μέχρι να φτάσει στο άκρο της σκακιέρας

```python
target = board[r][c]
if not target:
    moves.append((r, c))
elif target[0] != color:
    moves.append((r, c))
    break
else:
    break
```
- Χρησιμοποιεί την ίδια λογική με τους πύργους για τον καθορισμό έγκυρων κινήσεων κατά μήκος κάθε διαδρομής
- Τα κενά τετράγωνα είναι έγκυρες κινήσεις
- Τα κομμάτια του αντιπάλου μπορούν να αιχμαλωτιστούν (αλλά εμποδίζουν περαιτέρω κίνηση)
- Τα δικά του κομμάτια εμποδίζουν τη διαδρομή

### Συνάρτηση Κίνησης Βασίλισσας
```python
def get_queen_moves(board, row, col, color):
    # Συνδυασμός κινήσεων πύργου και αξιωματικού
    moves = get_rook_moves(board, row, col, color)
    moves.extend(get_bishop_moves(board, row, col, color))
    return moves
```
- Υπολογίζει έγκυρες κινήσεις για μια βασίλισσα στην καθορισμένη θέση
- Οι βασίλισσες συνδυάζουν την κίνηση τόσο των πύργων όσο και των αξιωματικών
- Απλώς συνδυάζει τα αποτελέσματα των συναρτήσεων κίνησης του πύργου και του αξιωματικού

### Συνάρτηση Κίνησης Βασιλιά
```python
def get_king_moves(board, row, col, color):
    moves = []
    king_moves = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    for dr, dc in king_moves:
        r, c = row + dr, col + dc
        if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
            target = board[r][c]
            if not target or target[0] != color:
                moves.append((r, c))
```
- Υπολογίζει έγκυρες κινήσεις για έναν βασιλιά στην καθορισμένη θέση
- Οι βασιλιάδες μπορούν να κινηθούν ένα τετράγωνο προς οποιαδήποτε κατεύθυνση (οριζόντια, κάθετα ή διαγώνια)
- Ελέγχεται καθένα από τα οκτώ γειτονικά τετράγωνα
- Μια κίνηση είναι έγκυρη αν είναι εντός της σκακιέρας και είτε κενή είτε περιέχει κομμάτι του αντιπάλου

### Συνάρτηση Ανίχνευσης Σαχ
```python
def is_square_under_attack(board, row, col, color):
    # Έλεγχος αν η συγκεκριμένη θέση είναι υπό επίθεση από τον αντίπαλο παίκτη
    opposite_color = 'b' if color == 'w' else 'w'
```
- Καθορίζει αν ένα τετράγωνο δέχεται επίθεση από τα κομμάτια του αντιπάλου
- Χρησιμοποιείται για να ελέγξει αν ένας βασιλιάς είναι σε σαχ ή αν μια κίνηση θα έβαζε/άφηνε τον βασιλιά σε σαχ
- Πρώτα καθορίζει το χρώμα του αντιπάλου

```python
# Έλεγχος στρατιωτών
pawn_dir = 1 if color == 'w' else -1
for dcol in [-1, 1]:
    r, c = row + pawn_dir, col + dcol
    if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        piece = board[r][c]
        if piece == opposite_color + 'p':
            return True
```
- Ελέγχει αν πιόνια του αντιπάλου μπορούν να επιτεθούν στο τετράγωνο
- Τα πιόνια επιτίθενται διαγώνια προς τα εμπρός, οπότε ελέγχει τα δύο τετράγωνα διαγώνια προς τα πίσω από την οπτική γωνία του τετραγώνου-στόχου

```python
# Έλεγχος ίππου
knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
for dr, dc in knight_moves:
    r, c = row + dr, col + dc
    if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        piece = board[r][c]
        if piece == opposite_color + 'n':
            return True
```
- Ελέγχει αν ίπποι του αντιπάλου μπορούν να επιτεθούν στο τετράγωνο
- Οι ίπποι επιτίθενται σε μοτίβο Γ, ελέγχοντας και τις οκτώ πιθανές θέσεις ίππου που θα μπορούσαν να επιτεθούν

```python
# Έλεγχος βασιλιά
king_moves = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
for dr, dc in king_moves:
    r, c = row + dr, col + dc
    if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        piece = board[r][c]
        if piece == opposite_color + 'k':
            return True
```
- Ελέγχει αν ο βασιλιάς του αντιπάλου μπορεί να επιτεθεί στο τετράγωνο
- Οι βασιλιάδες μπορούν να επιτεθούν σε οποιοδήποτε γειτονικό τετράγωνο, οπότε ελέγχει και τις οκτώ γύρω θέσεις

```python
# Έλεγχος πύργου, αξιωματικού και βασίλισσας
directions = {
    'straight': [(1, 0), (-1, 0), (0, 1), (0, -1)],
    'diagonal': [(1, 1), (1, -1), (-1, 1), (-1, -1)]
}
```
- Προετοιμάζεται για έλεγχο επιθέσεων από κομμάτια που κινούνται κατά μήκος γραμμών (πύργος, αξιωματικός, βασίλισσα)
- Ορίζει τις ευθείες και διαγώνιες κατευθύνσεις κίνησης για έλεγχο

```python
# Έλεγχος ίσιων γραμμών(πύργος και βασίλισσα)
for dr, dc in directions['straight']:
    for dist in range(1, BOARD_SIZE):
        r, c = row + dr * dist, col + dc * dist
        if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
            break
        piece = board[r][c]
        if piece:
            if piece[0] == opposite_color and (piece[1] == 'r' or piece[1] == 'q'):
                return True
            break
```
- Ελέγχει αν πύργοι ή βασίλισσες του αντιπάλου μπορούν να επιτεθούν στο τετράγωνο κατά μήκος ευθειών γραμμών
- Για καθεμία από τις τέσσερις ευθείες κατευθύνσεις, ελέγχει τετράγωνα σε αυξανόμενες αποστάσεις
- Αν βρεθεί πύργος ή βασίλισσα του αντιπάλου, το τετράγωνο δέχεται επίθεση
- Αν βρεθεί οποιοδήποτε κομμάτι (φίλιο ή εχθρικό), σταματά τον έλεγχο προς αυτή την κατεύθυνση (τα κομμάτια εμποδίζουν την οπτική επαφή)

```python
# Έλεγχος διαγώνιων γραμμών(αξιωματικός και βασίλισσα)
for dr, dc in directions['diagonal']:
    for dist in range(1, BOARD_SIZE):
        r, c = row + dr * dist, col + dc * dist
        if not (0 <= r < BOARD_SIZE και 0 <= c < BOARD_SIZE):
            break
        piece = board[r][c]
        if piece:
            if piece[0] == opposite_color and (piece[1] == 'b' or piece[1] == 'q'):
                return True
            break
```
- Ελέγχει αν αξιωματικοί ή βασίλισσες του αντιπάλου μπορούν να επιτεθούν στο τετράγωνο κατά μήκος διαγώνιων γραμμών
- Για καθεμία από τις τέσσερις διαγώνιες κατευθύνσεις, ελέγχει τετράγωνα σε αυξανόμενες αποστάσεις
- Αν βρεθεί αξιωματικός ή βασίλισσα του αντιπάλου, το τετράγωνο δέχεται επίθεση
- Αν βρεθεί οποιοδήποτε κομμάτι, σταματά τον έλεγχο προς αυτή την κατεύθυνση (τα κομμάτια εμποδίζουν την οπτική επαφή)

```python
return False
```
- Αν δε βρεθούν επιτιθέμενα κομμάτια μετά από όλους τους ελέγχους, το τετράγωνο δεν δέχεται επίθεση